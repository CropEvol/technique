# プログラムを高速化させる

## for文の最適化について
#### 講義で得た情報をまとめておきました。
#### ※ 現状C言語についてのみ記述。C言語でしか使えないものも多いですが、他言語でも使えそう・意識できそうなところがあれば使ってみてください。(他のテクニック等あれば順次追加して行ってくれると助かります。)
#### 時間があればpython/perl等に適応させていきます。

では始まり。
以下の様なプログラムを仮定

```ダメな例
for(i=0;i<Ni;i++){
  実行文A; /* Ni回 */
    for(j=0;j<Nj;j++){
      実行文B; /* Ni*Nj回 */
        for(k=0;k<Nk;k++){
          実行文C; /* Ni*Nj*Nk回 */
        }
    }
}
```

### 最適化手法

(1)定数計算の除去
``a=3+4``
などの定数同士の演算を削減する,
あらかじめ演算を行っておく。``a=7``

(2)型変換の除去
整数型 ⇔ 実数型, 単精度 ⇔ 倍精度
の様に途中で型変換が生じない様に型指定をする・計算のプログラムを組む。

(3)共通式の除去
s=t+a; y=x+s; u=t+a; z=w+u;の場合, uは明らかに必要ない

(4)不変式の除去
実行文Cの中に,``s=c[i][j]+d[i][j]``がある場合には,それは実行文Bに移動できる

(5)単純代入の除去
``a=b; b=a;``の場合``b=a``は必要ない

(6)演算の変更
整数の場合
÷2(除算) ⇒ >> 1(ビットシフト)
浮動小数点数の場合
÷2(除算) ⇒ ×0.5(乗算)
べき乗pow(a,3) ⇒ 乗算a × a × a
ベタ書きの方が速い。
乗算x × 2 ⇔ 加算 x + x
乗算と加算のどちらの計算を使うべきかは, 回路の状態による


(7)ループのアンローリング

```
tmp=0;
for(i=0;i<100;i++){
  tmp=tmp+a[i]*b[i];
}
```

以下のように書き換える

```
tmp0=0; tmp1=0; tmp2=0; tmp3=0;
for(i=0;i<100;i=i+4){
  tmp0=tmp0+a[i]*b[i];
  tmp1=tmp1+a[i+1]*b[i+1];
  tmp2=tmp2+a[i+2]*b[i+2];
  tmp3=tmp3+a[i+3]*b[i+3];
}
tmp=tmp0+tmp1+tmp2+tmp3;
```

なぜ, ループのアンローリングを行わなければならないのか?
out of order実行では,アンローリングによって,広い範囲から実行可能命令を探せるようになり,選択肢を増やす効果があり,特に並列実行の可能性が高くなる.早い段階でデータのロード命令を発行できるようになることで,スカラ計算機の狭いバンド幅を少しでも有効に活用するための手段という役割が最も重要
その他の目的として,条件比較の回数削減,コンパイラやCPUがレジスタの割り当てを上手に行えるようになるというメリットがある。

(9)ループの融合

```
for(i=0;i<100;i++){ 実行文D; }
for(i=0;i<100;i++){ 実行文E; }
```

以下のように, 融合する.

```
for(i=0;i<100;i++){
  実行文D;
  実行文E;
}
```

out of order実行では, 広い範囲から実行可能命令を探せるようになり, 選択肢を増やす効果ある, 融合したことにより, 共通式の除去, 不変式の除去, 単純代入の除去などが行える可能性が出現する

(10)ループ

```
1重化
for(i=0;i<100;i++)
  for(j=0;j<300;j++){
    実行文D;
  }
```

```
for(k=0;k<30000;k++){
  i=k / 300;
  j=k % 300;
  実行文D;
}
```

OpenMPのため

(11)ループの分配
ループの融合の逆の操作,分配したほうがよくなる場合もある。それぞれの実行文が完全に独立・依存していない場合など。

(12)ループのブロック化

```
for(i=0;i<N;i++){
  for(j=0;j<N;k++){
    A[j][i]=B[i][j];
  }
}
```

```
for(ii=0;ii<N;ii=ii+M){
  for(jj=0;jj<N;jj=jj+M){
    for(i=ii;ii<min(ii+M,N);i++){
      for(j=jj;j<min(jj+M,N);j++){
        A[j][i]=B[i][j];
      }
    }
  }
}
```


(13)配列要素の単純変数化

```
for(i=0;i<100;i++){
  t[i]=a[i]+b[i];
  s[i]=(2*t[i]+3)*t[i]+4;
}
```
t[i]のデータが今後参照されることがないならば, t[i]の代わりに, tmpという変数に変更する, 配列の場合には, メモリに計算結果を格納するためのストアが行われる可能性があるが, 変数tmpの場合には, ループの途中では, キャッシュに格納されるのみである

(14)配列の参照方向
C言語の場合

```
A[0][0] A[0][1] A[0][2] A[0][3] A[0][4]
A[1][0] A[1][1] A[1][2] A[1][3] A[1][4]
A[2][0] A[2][1] A[2][2] A[2][3] A[2][4]
A[3][0] A[3][1] A[3][2] A[3][3] A[3][4]
A[4][0] A[4][1] A[4][2] A[4][3] A[4][4]
```

横方向への+1ストライドのデータ参照は, メモリにおいて連続アクセスとなるが, 縦方向への+1ストライドのデータ参照は, 不連続アクセスとなる, 添え字の変化は, 一番右側のインデックスに対して行うようにする

Fortranは, 上記の逆

```
A(1,1) A(1,2) A(1,3) A(1,4) A(1,5)
A(2,1) A(2,2) A(2,3) A(2,4) A(2,5)
A(3,1) A(3,2) A(3,3) A(3,4) A(3,5)
A(4,1) A(4,2) A(4,3) A(4,4) A(4,5)
A(5,1) A(5,2) A(5,3) A(5,4) A(5,5)
```

縦方向への+1ストライドのデータ参照は, メモリにおいて連続アクセスとなるが, 横方向への+1ストライドのデータ参照は, 不連続アクセスとなる. 添え字の変化は, 一番左側のインデックスに対して行うようにする.

(15)インライン展開
Ｃ言語における関数呼び出しは, スタックに, 戻り先の情報と引数を格納する必要がある, もちろん, 関数の先頭にジャンプする必要もある, よって, オーバーヘッドが大きい, 関数呼び出しをしている部分に, 関数の内容そのものを埋め込むことで, オーバーヘッドをなくす

(16)ライブラリの活用
密行列のためのBLASやLAPACKライブラリの活用
FFTライブラリの活用
多倍長数ライブラリの活用

(17)配列の大きさ
セット・アソシアティブ・キャッシュ(連想方式)の関係で, 2nのストライドでのデータ参照においては, キャッシュの一部分しか使うことができずに, データの入れ替えが起きる可能性がある。
2m × 2nの行列サイズの問題を解く場合には, (2m + 1) × (2n + 1)の領域を確保しておき, その中の(2m) × (2n)の部分のみを計算に利用すると高速に計算できる場合もある。

M × N の行列を使って計算を行う場合,
double a[M*N];と確保して, a[N*i+j]でアクセスをすれば, 2次元の配列が1次元の配列になるので、セット・アソシアティブ・キャッシュの問題と無縁でいられると考えるのは間違い。
ここでの主張は, M やN として, 2mや2nを使ってはいけないという意味である。
よって, 仮に1次元の配列として確保しようとも, 2次元以上の配列においては, セット・アソシアティブ・キャッシュの問題は注意しなければならない。
